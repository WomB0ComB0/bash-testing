#!/bin/bash
# -*- shell -*-

# Signal Handler System - Bash Edition
# A robust signal handling system that catches and reports on Unix signals

set -euo pipefail

# Configuration
SCRIPT_NAME="$(basename "$0")"
LOG_FILE="${LOG_FILE:-/tmp/signal_handler_bash_$$.log}"
PID=$$
START_TIME=$(date +%s)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Signal database
declare -A SIGNAL_INFO=(
    ["1"]="SIGHUP:Hangup detected on controlling terminal:standard:true:true"
    ["2"]="SIGINT:Interrupt from keyboard (Ctrl+C):standard:true:true"
    ["3"]="SIGQUIT:Quit from keyboard (Ctrl+\\):standard:true:true"
    ["4"]="SIGILL:Illegal instruction:standard:true:true"
    ["5"]="SIGTRAP:Trace/breakpoint trap:standard:true:true"
    ["6"]="SIGABRT:Abort signal from abort():standard:true:true"
    ["7"]="SIGBUS:Bus error (bad memory access):standard:true:true"
    ["8"]="SIGFPE:Floating-point exception:standard:true:true"
    ["9"]="SIGKILL:Kill signal (cannot be caught):standard:false:true"
    ["10"]="SIGUSR1:User-defined signal 1:standard:true:true"
    ["11"]="SIGSEGV:Segmentation violation:standard:true:true"
    ["12"]="SIGUSR2:User-defined signal 2:standard:true:true"
    ["13"]="SIGPIPE:Broken pipe:standard:true:true"
    ["14"]="SIGALRM:Timer signal from alarm():standard:true:true"
    ["15"]="SIGTERM:Termination signal:standard:true:true"
    ["16"]="SIGSTKFLT:Stack fault on coprocessor:standard:true:true"
    ["17"]="SIGCHLD:Child stopped or terminated:job_control:true:false"
    ["18"]="SIGCONT:Continue if stopped:job_control:true:false"
    ["19"]="SIGSTOP:Stop process (cannot be caught):job_control:false:false"
    ["20"]="SIGTSTP:Stop typed at terminal (Ctrl+Z):job_control:true:false"
    ["21"]="SIGTTIN:Terminal input for background process:job_control:true:false"
    ["22"]="SIGTTOU:Terminal output for background process:job_control:true:false"
    ["23"]="SIGURG:Urgent condition on socket:system:true:false"
    ["24"]="SIGXCPU:CPU time limit exceeded:system:true:true"
    ["25"]="SIGXFSZ:File size limit exceeded:system:true:true"
    ["26"]="SIGVTALRM:Virtual alarm clock:system:true:true"
    ["27"]="SIGPROF:Profiling timer expired:system:true:true"
    ["28"]="SIGWINCH:Window resize signal:system:true:false"
    ["29"]="SIGIO:I/O now possible:system:true:false"
    ["30"]="SIGPWR:Power failure:system:true:true"
    ["31"]="SIGSYS:Bad system call:system:true:true"
)

# Function to get emoji for signal category
get_signal_emoji() {
    local category="$1"
    local terminates="$2"
    
    case "$category" in
        "standard")
            if [[ "$terminates" == "true" ]]; then
                echo "💀"
            else
                echo "⚡"
            fi
            ;;
        "job_control") echo "🎮" ;;
        "system") echo "🔧" ;;
        "realtime") echo "⏰" ;;
        *) echo "📡" ;;
    esac
}

# Function to log messages
log_message() {
    local message="$1"
    local timestamp=$(date --iso-8601=seconds)
    
    echo -e "$message"
    echo -e "[$timestamp] $message" | sed 's/\x1b\[[0-9;]*m//g' >> "$LOG_FILE"
}

# Function to parse signal info
parse_signal_info() {
    local signal_num="$1"
    local info="${SIGNAL_INFO[$signal_num]:-}"
    
    if [[ -z "$info" ]]; then
        echo "UNKNOWN:Unknown signal:unknown:false:true"
        return
    fi
    
    echo "$info"
}

# Function to get process status
get_process_status() {
    local uptime=$(($(date +%s) - START_TIME))
    local memory_kb=$(awk '/VmRSS/ {print $2}' /proc/$$/status 2>/dev/null || echo "0")
    local memory_mb=$((memory_kb / 1024))
    
    echo "PID: $PID, Uptime: ${uptime}s, Memory: ${memory_mb}MB"
}

# Main signal handler function
handle_signal() {
    local signal_num="$1"
    local timestamp=$(date --iso-8601=seconds)
    
    # Parse signal information
    IFS=':' read -r name description category catchable terminates <<< "$(parse_signal_info "$signal_num")"
    
    # Get emoji for the signal
    local emoji=$(get_signal_emoji "$category" "$terminates")
    
    # Format the message
    local message="${emoji} [${timestamp}] SIGNAL CAUGHT: ${name} (${signal_num})
   ${CYAN}Category:${NC} ${category^^}
   ${BLUE}Description:${NC} ${description}
   ${GREEN}Catchable:${NC} ${catchable^}
   ${RED}Terminates:${NC} ${terminates^}
   ${YELLOW}Process:${NC} $(get_process_status)
$(printf '─%.0s' {1..80})"
    
    log_message "$message"
    
    # Handle specific signal behaviors
    handle_signal_behavior "$signal_num" "$name" "$terminates"
}

# Function to handle specific signal behaviors
handle_signal_behavior() {
    local signal_num="$1"
    local name="$2"
    local terminates="$3"
    
    case "$signal_num" in
        "2") # SIGINT
            log_message "${RED}🛑 Graceful shutdown initiated...${NC}"
            graceful_shutdown 0
            ;;
        "15") # SIGTERM
            log_message "${RED}🔚 Termination requested...${NC}"
            graceful_shutdown 0
            ;;
        "10") # SIGUSR1
            log_message "${GREEN}📊 Status report requested${NC}"
            print_status
            ;;
        "12") # SIGUSR2
            log_message "${BLUE}🔄 Configuration reload requested${NC}"
            reload_configuration
            ;;
        "28") # SIGWINCH
            log_message "${PURPLE}📏 Terminal window resized${NC}"
            ;;
        "17") # SIGCHLD
            log_message "${CYAN}👶 Child process state changed${NC}"
            ;;
        *)
            if [[ "$terminates" == "true" ]]; then
                log_message "${RED}⚠️  Fatal signal received. Preparing for shutdown...${NC}"
                graceful_shutdown 1
            fi
            ;;
    esac
}

# Function for graceful shutdown
graceful_shutdown() {
    local exit_code="${1:-0}"
    
    log_message "${GREEN}🧹 Performing cleanup...${NC}"
    
    # Remove trap handlers
    trap - $(seq 1 31 | tr '\n' ' ')
    
    log_message "${GREEN}✅ Cleanup completed. Exiting...${NC}"
    exit "$exit_code"
}

# Function to print process status
print_status() {
    local uptime=$(($(date +%s) - START_TIME))
    local memory_info=""
    
    if [[ -r "/proc/$$/status" ]]; then
        local memory_kb=$(awk '/VmRSS/ {print $2}' /proc/$$/status)
        local memory_mb=$((memory_kb / 1024))
        memory_info="Memory: ${memory_mb}MB RSS"
    else
        memory_info="Memory: Unable to read"
    fi
    
    log_message "${GREEN}📈 Process Status:
   PID: $PID
   Uptime: ${uptime}s
   $memory_info
   Log: $LOG_FILE${NC}"
}

# Function to reload configuration
reload_configuration() {
    log_message "${BLUE}🔄 Configuration reload not implemented in this example${NC}"
}

# Function to list all signals
list_all_signals() {
    echo -e "${GREEN}📋 Available Signals:${NC}"
    printf '─%.0s' {1..100}; echo
    
    for signal_num in $(printf '%s\n' "${!SIGNAL_INFO[@]}" | sort -n); do
        IFS=':' read -r name description category catchable terminates <<< "${SIGNAL_INFO[$signal_num]}"
        local emoji=$(get_signal_emoji "$category" "$terminates")
        printf "%s %2d) %-12s - %s\n" "$emoji" "$signal_num" "$name" "$description"
    done
}

# Function to get signal information
get_signal_info() {
    local input="$1"
    local signal_num=""
    
    # Check if input is a number
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        signal_num="$input"
    else
        # Search for signal by name
        for num in "${!SIGNAL_INFO[@]}"; do
            IFS=':' read -r name _ _ _ _ <<< "${SIGNAL_INFO[$num]}"
            if [[ "$name" == "${input^^}" ]]; then
                signal_num="$num"
                break
            fi
        done
    fi
    
    if [[ -z "$signal_num" ]] || [[ -z "${SIGNAL_INFO[$signal_num]:-}" ]]; then
        echo -e "${RED}❌ Signal '$input' not found${NC}"
        return 1
    fi
    
    IFS=':' read -r name description category catchable terminates <<< "${SIGNAL_INFO[$signal_num]}"
    local emoji=$(get_signal_emoji "$category" "$terminates")
    
    echo -e "${GREEN}📡 Signal Information: $name${NC}
   Number: $signal_num
   Description: $description
   Category: $category
   Catchable: ${catchable^}
   Terminates: ${terminates^}"
}

# Function to setup signal handlers
setup_handlers() {
    # List of catchable signals (excluding SIGKILL and SIGSTOP)
    local catchable_signals=(1 2 3 4 5 6 7 8 10 11 12 13 14 15 16 17 18 20 21 22 23 24 25 26 27 28 29 30 31)
    
    for signal_num in "${catchable_signals[@]}"; do
        if [[ -n "${SIGNAL_INFO[$signal_num]:-}" ]]; then
            IFS=':' read -r name _ _ catchable _ <<< "${SIGNAL_INFO[$signal_num]}"
            if [[ "$catchable" == "true" ]]; then
                trap "handle_signal $signal_num" "$signal_num"
            fi
        fi
    done
}

# Function to run tests
run_tests() {
    echo -e "${GREEN}🧪 Testing signal handling...${NC}"
    echo -e "${BLUE}Send signals to this process (PID: $PID)${NC}"
    echo -e "${YELLOW}Try: kill -USR1 $PID${NC}"
    echo -e "${YELLOW}Try: kill -USR2 $PID${NC}"
    echo -e "${YELLOW}Try: kill -WINCH $PID${NC}"
    echo -e "${YELLOW}Press Ctrl+C to test SIGINT${NC}"
}

# Help function
show_help() {
    cat << EOF
${GREEN}Signal Handler System - Bash Edition${NC}

Usage:
  $SCRIPT_NAME [options]

Options:
  --help, -h          Show this help message
  --list, -l          List all available signals
  --info <signal>     Get information about a specific signal
  --log <file>        Specify log file (default: /tmp/signal_handler_bash_PID.log)
  --test              Send test signals to demonstrate handling

Environment Variables:
  LOG_FILE           Override default log file location

Examples:
  $SCRIPT_NAME --list
  $SCRIPT_NAME --info SIGTERM
  $SCRIPT_NAME --info 15
  LOG_FILE=/tmp/my_signals.log $SCRIPT_NAME
  $SCRIPT_NAME --test

EOF
}

# Main function
main() {
    local